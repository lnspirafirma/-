# ------------------------------------------------------------------
# Data rights-warehouse_AI
# ถือครองโดย Inspirafirma โครงการเพื่อเชื่อมต่อ
# ------------------------------------------------------------------

import uuid
import os
from typing import Dict, List, Any, Optional
from datetime import datetime

# External Libraries
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from openai import AsyncOpenAI  # ใช้ AsyncOpenAI สำหรับ FastAPI

# --- 1. Application Setup ---
app = FastAPI(
    title="AI Service Template (Inspirafirma Edition)",
    description="A professional template for deploying AI models (NLP, Video Gen) as a stateless API.",
    version="1.0.0"
)

# --- 2. AI Client Setup ---
# อ่านค่า API Key จาก Environment Variables เพื่อความปลอดภัย
# คำเตือน: อย่าลืมตั้งค่า export GEMINI_API_KEY="your_actual_key_here" ใน Terminal ก่อนรัน
API_KEY = os.getenv("GEMINI_API_KEY")

if not API_KEY:
    # หมายเหตุ: เพื่อให้โค้ดรันได้ในการทดสอบ เราอาจจะข้าม Error นี้ไปก่อน
    # แต่ในการใช้งานจริงควร Uncomment บรรทัดข้างล่าง
    # raise ValueError("GEMINI_API_KEY environment variable not set.")
    print("Warning: GEMINI_API_KEY not set. AI calls will fail.")

# ตั้งค่า Client ให้ชี้ไปที่ Google Gemini ผ่าน OpenAI Compatibility Layer
ai_client = AsyncOpenAI(
    api_key=API_KEY if API_KEY else "missing-key",
    base_url="https://generativelanguage.googleapis.com/v1beta/openai/"
)

# --- 3. Pydantic Data Models (Request/Response Schemas) ---

class MessageInput(BaseModel):
    """Input schema for text analysis."""
    content: str = Field(..., description="The text content to be analyzed.", min_length=1)
    user_id: Optional[str] = None
    session_id: Optional[str] = None

class AnalysisResponse(BaseModel):
    """Output schema for text analysis."""
    analysis_id: str = Field(..., description="Unique ID for this analysis request.")
    timestamp: datetime = Field(..., description="Time of the analysis.")
    is_intentful: bool = Field(False, description="Whether the model detected a specific intent.")
    emotional_tone: str = Field("Neutral", description="Detected emotional tone.")
    confidence: float = Field(0.0, description="Confidence score (0.0 to 1.0).")
    entities: List[Dict[str, Any]] = Field([], description="List of recognized entities.")
    embedding: List[float] = Field([], description="Vector embedding of the content.") # (NEW) Field

class VideoRequest(BaseModel):
    """Input schema for video generation."""
    prompt: str = Field(..., description="The text prompt to generate video from.", min_length=10)
    style: Optional[str] = Field("cinematic", description="Desired style of the video.")

class VideoResponse(BaseModel):
    """Output schema for video generation."""
    job_id: str = Field(..., description="The unique ID for the generation job.")
    status: str = Field("pending", description="Current status of the job (e.g., pending, processing, completed).")
    estimated_duration_sec: int = Field(60, description="Estimated time in seconds.")

# --- 4. AI Service Logic ---

async def analyze_text_placeholder(text: str) -> Dict[str, Any]:
    """
    (Function - MODIFIED) 
    Calls the AI embedding service and provides mock data for other fields.
    """
    print(f"Analyzing text and getting embedding for: '{text[:20]}...'")
    
    embedding_vector = []
    
    # --- Call AI Service (Embeddings) ---
    try:
        if API_KEY:
            # เรียกใช้ Google Gemini Embedding model
            embedding_response = await ai_client.embeddings.create(
                input=text,
                model="text-embedding-004" # หรือ gemini-embedding-001 ตามที่มี
            )
            embedding_vector = embedding_response.data[0].embedding
            print(f"Successfully retrieved embedding with dimension: {len(embedding_vector)}")
        else:
            print("Skipping AI call due to missing API Key.")
            # Mock embedding for testing without key
            embedding_vector = [0.1] * 768 
            
    except Exception as e:
        print(f"Error calling AI embedding service: {e}")
        # ดำเนินการต่อด้วย embedding ว่าง หรือค่า default
    
    # --- Mock Logic for other fields ---
    entities_found = []
    if "agio" in text.lower():
        entities_found.append({"text": "agio", "type": "PERSON", "start": 0, "end": 4})
        
    is_intentful = len(text) > 10 or bool(entities_found)
    tone = "Positive" if "good" in text.lower() else "Neutral"
    
    return {
        "is_intentful": is_intentful,
        "emotional_tone": tone,
        "confidence": 0.85 if is_intentful else 0.3,
        "entities": entities_found,
        "embedding": embedding_vector
    }

async def generate_video_placeholder(prompt: str, style: str) -> Dict[str, Any]:
    """
    (Placeholder Function)
    Integrate your real Video Generation API here.
    """
    print(f"Submitting video job for prompt: '{prompt}' with style: '{style}'")
    job_id = f"vid_job_{uuid.uuid4()}"
    
    return {
        "job_id": job_id,
        "status": "pending",
        "estimated_duration_sec": 90
    }

# --- 5. API Endpoints ---

@app.post("/analyze", response_model=AnalysisResponse, summary="Analyze Text Content (with Embedding)")
async def analyze_message_endpoint(input_data: MessageInput):
    """
    Analyzes a single message using the AI backend.
    """
    if not input_data.content:
        raise HTTPException(status_code=422, detail="Content cannot be empty.")
    
    try:
        # Call the service logic
        analysis_results = await analyze_text_placeholder(input_data.content)
        
        return AnalysisResponse(
            analysis_id=f"anl_{uuid.uuid4()}",
            timestamp=datetime.utcnow(),
            is_intentful=analysis_results.get("is_intentful", False),
            emotional_tone=analysis_results.get("emotional_tone", "Neutral"),
            confidence=analysis_results.get("confidence", 0.0),
            entities=analysis_results.get("entities", []),
            embedding=analysis_results.get("embedding", [])
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

@app.post("/generate-video", response_model=VideoResponse, summary="Submit Video Generation Job")
async def generate_video_endpoint(request: VideoRequest):
    """
    Submits a prompt to generate an AI video.
    """
    try:
        video_job = await generate_video_placeholder(request.prompt, request.style)
        
        return VideoResponse(
            job_id=video_job.get("job_id"),
            status=video_job.get("status", "failed"),
            estimated_duration_sec=video_job.get("estimated_duration_sec", 0)
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

# หมายเหตุ: วิธีการรันเซิร์ฟเวอร์
# uvicorn ai_service_core:app --reload

